# Namespaces and Modules ネームスペースとモジュール

>用語についての注意：TypeScript 1.5では、その命名法が変更されていることに注意することが重要です。
「内部モジュール」は 「ネームスペース」になりました。
ECMAScript 2015の用語に合わせて、「外部モジュール」は単に「モジュール」になっています（つまり、`module X {` は現在好ましい `namespace X {` と同等です）。


## Introduction 導入

この記事では、TypeScript のネームスペースとモジュールを使用してコードを整理するさまざまな方法を概説します。
また、ネームスペースとモジュールを使用する方法に関するいくつかの高度なトピックについて説明し、それらを TypeScript で使用する際の一般的な落とし穴に対処します。

モジュールの詳細については、[モジュール](./MODULES.md)のドキュメントを参照してください。
ネームスペースの詳細については、[ネームスペース](./NAMESPACES.md)のドキュメントを参照してください。


## Using Namespaces ネームスペースの利用

ネームスペースは、グローバルネームスペース内の JavaScript オブジェクトと呼ばれます。
これにより、ネームスペースは非常に単純な構造になります。
複数のファイルにまたがることができ、 `--outFile` を使用して連結することができます。
ネームスペースは、HTMLページに `<script>` タグとして含まれるすべての依存関係を使用して、Webアプリケーションでコードを構造化するのに適した方法です。

グローバルなネームスペースの汚染と同様に、特に大きなアプリケーションでは、コンポーネントの依存関係を特定するのが難しい場合があります。


## Using Modules モジュールの利用

ネームスペースと同様に、モジュールはコードと宣言の両方を含むことができます。 
主な違いは、モジュールが依存関係を宣言することです。

モジュールはまた、モジュールローダ（ CommonJs/Require.js など）に依存します。
小さなJSアプリケーションの場合、これは最適ではないかもしれませんが、大規模なアプリケーションの場合、長期的なモジュール性と保守性の利点があります。
モジュールは、コードの再利用性を高め、分離を強化し、バンドリングのツールリングを改善します。

Node.js アプリケーションでは、モジュールがデフォルトであり、コードを構造化するための推奨される方法であることにも注意してください。

ECMAScript 2015以降、モジュールは言語の本来の部分であり、すべての準拠エンジン実装でサポートされる必要があります。
したがって、新しいプロジェクトでは、モジュールが推奨されるコード構成の仕組みになります。


## Pitfalls of Namespaces and Modules ネームスペースとモジュールの落とし穴

このセクションでは、ネームスペースとモジュールを使用する際の一般的な落とし穴とその回避方法について説明します。


### `/// <reference>-` ing a module

よくある間違いは、 `import` ステートメントを使用するのではなく、 `/// <reference ... />` 構文を使用してモジュールファイルを参照しようとすることです。
この区別を理解するためには、まず、コンパイラがどのようにインポートのパスに基づいてモジュールの型情報を見つけることができるかを理解する必要があります。
（例えば `import x from "...";`）や、 `import x = require("...");`、その他の `...` のパスなど）

 コンパイラは適切なパスを持つ `.ts`、 `.tsx` 、 `.d.ts` を見つけようとします。
 特定のファイルが見つからなかった場合、コンパイラは環境モジュールの宣言を探します。
 これらを `.d.ts` ファイルで宣言する必要があることを思い出してください。
 
 - `myModules.d.ts`
```typescript
// In a .d.ts file or .ts file that is not a module:
declare module "SomeModule" {
    export function fn(): string;
}
```
 
 - `myOtherModule.ts`
 ```typescript
/// <reference path="myModules.d.ts" />
import * as m from "SomeModule";
```

ここでの参照タグは、環境モジュールの宣言を含む宣言ファイルを見つけることができます。 
これは、TypeScript サンプルのいくつかが使用する `node.d.ts` ファイルが消費される方法です。


### Needless Namespacing 不要なネームスペース

プログラムをネームスペースからモジュールに変換する場合は、次のようなファイルで簡単に終了できます。

- `shapes.ts`
```typescript
export namespace Shapes {
    export class Triangle { /* ... */ }
    export class Square { /* ... */ }
}
```

ここの `Shapes` のトップレベルモジュールは、理由がないために `Triangle` と `Square` を囲みます。 これはあなたのモジュールの消費者にとって混乱し迷惑です。

- `shapeConsumer.ts`
```typescript
import * as shapes from "./shapes";
let t = new shapes.Shapes.Triangle(); // shapes.Shapes?
```

TypeScriptのモジュールの重要な特徴は、2つの異なるモジュールが同じスコープに名前を提供しないことです。
モジュールのコンシューマは、割り当てる名前を決定するため、エクスポートされたシンボルをネームスペースに積極的にまとめておく必要はありません。

なぜあなたがモジュールの内容をネームスペースに入れようとすべきではないかを繰り返すために、ネームスペースの一般的な考え方は、構造の論理的なグループ化を提供し、名前の衝突を防ぐことです。
モジュールファイル自体はすでに論理グループになっており、そのトップレベルの名前はインポートするコードで定義されているため、エクスポートされたオブジェクトに追加のモジュールレイヤーを使用する必要はありません。

ここに改訂例があります。

- `shapes.ts`
```typescript
export class Triangle { /* ... */ }
export class Square { /* ... */ }
```

- `shapeConsumer.ts`
```typescript
import * as shapes from "./shapes";
let t = new shapes.Triangle();
```


### Trade-offs of Modules モジュールのトレードオフ

JSファイルとモジュールとの間には1対1の対応があるのと同様に、TypeScript はモジュールソースファイルと放出されるJSファイルの間に1対1の対応関係を持っています。
これの1つの効果は、ターゲットとするモジュールシステムに応じて複数のモジュールソースファイルを連結することができないことです。
たとえば、 `commonjs` や `umd` をターゲットにして `outFile` オプションを使用することはできませんが、TypeScript 1.8以降では、 `amd` や `system` をターゲットにするときに `outFile` を使用することができます。
