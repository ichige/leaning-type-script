# Triple-Slash Directives - `///` ディレクティブ

トリプルスラッシュディレクティブは、単一のXMLタグを含む1行のコメントです。 
コメントの内容はコンパイラ指令として使用されます。

トリプルスラッシュディレクティブは、そのファイルを含むファイルの先頭にのみ有効です。 
トリプルスラッシュディレクティブは、他のトリプルスラッシュディレクティブを含め、単一行または複数行のコメントの前に置くことができます。 
それらがステートメントまたは宣言の後で出会った場合、それらは通常の単一行のコメントとして扱われ、特別な意味を持ちません。


## `/// <reference path="..." />`

`/// <reference path="..." />` ディレクティブは、このグループの中で最も一般的です。 
ファイル間の依存関係の宣言として機能します。

トリプルスラッシュ参照は、コンパイルプロセスに追加のファイルを含めるようにコンパイラに指示します。

また、 `--out` または `--outFile` を使用して出力を順序付ける方法としても機能します。 
ファイルは、前処理パス後の入力と同じ順序で出力ファイルの場所に出力されます。


### Preprocessing input files - 入力ファイルの前処理

コンパイラは入力ファイルに対して前処理パスを実行して、すべてのトリプルスラッシュ参照ディレクティブを解決します。 
このプロセス中に、追加のファイルがコンパイルに追加されます。

プロセスは一連のルートファイルから始まります。 
これらはコマンドラインまたは `tsconfig.json` ファイルの `"files"` リストで指定されたファイル名です。 
これらのルートファイルは、指定されたのと同じ順序で前処理されます。 
ファイルがリストに追加される前に、そのファイル内のすべてのトリプルスラッシュ参照が処理され、ターゲットが含まれます。 
トリプルスラッシュの参照は、ファイル内に表示されている順序で深さ優先で解決されます。

トリプルスラッシュの参照パスは、格納されていないファイルの場合は、そのファイルを基準に解決されます。

### Errors - エラー

存在しないファイルを参照するのはエラーです。 
ファイルがトリプルスラッシュ参照を持つのはエラーです。


### Using `--noResolve@` - `--noResolve` の使用

コンパイラフラグ `--noResolve` を指定すると、トリプルスラッシュ参照は無視されます。 
新しいファイルを追加することも、提供されるファイルの順序を変更することもありません。


## `/// <reference types="..." />`

`/// <reference path="..." />` ディレクティブと同様に、このディレクティブは依存関係の宣言として機能します。 
しかし、 `/// <reference types="..." />` ディレクティブは、パッケージに対する依存関係を宣言します。

これらのパッケージ名を解決するプロセスは、 `import` ステートメントでモジュール名を解決するプロセスと同様です。 
トリプルスラッシュリファレンス型のディレクティブを考える簡単な方法は、宣言パッケージの `import` です。

たとえば、 `/// <reference types="node" />` を宣言ファイルに含めると、このファイルは `@types/node/index.d.ts` で宣言された名前を使用することが宣言されます。 
したがって、このパッケージは、宣言ファイルとともにコンパイルに含める必要があります。

`d.ts` ファイルを手動で作成する場合にのみ、これらのディレクティブを使用します。

コンパイル時に生成される宣言ファイルの場合、コンパイラは自動的に `/// <reference types="..." />` を追加します。 
生成された宣言ファイルの `/// <reference types="..." />` は、結果のファイルが参照されたパッケージの宣言を使用する場合にのみ追加されます。

`.ts` ファイルの `@types` パッケージへの依存関係を宣言するには、代わりにコマンドラインまたは `tsconfig.json` で `--types` を使用します。 
詳細については、 [`tsconfig.json` ファイルの `@types`、 `typeRoots`、および `types` の使用](./TSCONFIG-JSOON.md)を参照してください。

## `/// <reference no-default-lib="true"/>`

このディレクティブは、ファイルをデフォルトのライブラリとしてマークします。 
このコメントは、 `lib.d.ts` とその変形の一番上に表示されます。

このディレクティブは、デフォルトのライブラリ（ `lib.d.ts` ）をコンパイルに含めないようにコンパイラに指示します。 
ここでの影響は、コマンドラインで `--noLib` を渡すのと同様です。

また、 `--skipDefaultLibCheck` を渡すとき、コンパイラは `/// <reference no-default-lib="true" />` を持つファイルのチェックだけをスキップすることにも注意してください。


## `/// <amd-module />`

デフォルトでは、AMD モジュールは匿名で生成されます。 
これは、結果のモジュールを処理するために他のツール（例えば、 `r.js` など）が使用されている場合に問題を引き起こす可能性があります。

`amd-module` ディレクティブでは、オプションのモジュール名をコンパイラに渡すことができます。

**amdModule.ts**
```typescript
///<amd-module name="NamedModule"/>
export class C {
}
```

AMD `defined` の呼び出しの一部として `NamedModule` という名前をモジュールに代入します。

**amdModule.js**
```typescript
define("NamedModule", ["require", "exports"], function (require, exports) {
    var C = (function () {
        function C() {
        }
        return C;
    })();
    exports.C = C;
});
```

## `/// <amd-dependency />`

> 注: このディレクティブは推奨されていません。 代わりに `import "moduleName"` ステートメントを使用します。

`/// <amd-dependency path="x" />` 結果のモジュールの `require` 呼び出しで注入する必要のある非 TS モジュールの依存性をコンパイラに通知します。

`amd-dependency` ディレクティブにはオプションの `name` プロパティを指定することもできます。 
これにより、 `amd-dependency` にオプションの名前を渡すことができます。

```typescript
/// <amd-dependency path="legacy/moduleA" name="moduleA"/>
declare var moduleA:MyType
moduleA.callStuff()
```

生成されたJSコード…

```javascript
define(["require", "exports", "legacy/moduleA"], function (require, exports, moduleA) {
    moduleA.callStuff()
});
```
